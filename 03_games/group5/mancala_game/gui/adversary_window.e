note
	description: "EiffelVision Widget ADVERSARY_WINDOW.%
		%The original version of this class was generated by EiffelBuild."
	generator: "EiffelBuild"
	date: "$Date: 2010-12-22 10:39:24 -0800 (Wed, 22 Dec 2010) $"
	revision: "$Revision: 85202 $"

class
	ADVERSARY_WINDOW

inherit
	ADVERSARY_WINDOW_IMP


feature {NONE} -- Initialization

	default_button_color : EV_COLOR

	user_create_interface_objects
			-- Create any auxilliary objects needed for ADVERSARY_WINDOW.
			-- Initialization for these objects must be performed in `user_initialization'.
		do
				-- Create attached types defined in class here, initialize them in `user_initialization'.
		end

	user_initialization
			-- Perform any initialization on objects created by `user_create_interface_objects'
			-- and from within current class itself.
		do
				-- Initialize types defined in current class
			default_button_color := list_button_hole.i_th (1).background_color
		end

feature {NONE} -- Implementation

	action_hole_click(a_hole:INTEGER)
		do
				-- Create a new 'ACTION_SELECT' with the selected
				-- hole as a parameter
				send_action_to_game_manager(create {ACTION_SELECT}.make (a_hole))
		end

	action_hint_click
		do
				-- Create a new 'ACTION_OTHER' with an '{ENUM_OTHER}.hint'
				-- as a parameter
				send_action_to_game_manager (create {ACTION_OTHER}.make ((create {ENUM_OTHER}).hint))
		end

	action_log_click
		do
				-- Toggle 'text_log' visibility and change the text
				-- of the button according to the status of 'text_log'
				if(text_log.is_show_requested)then
					-- Hide log
					text_log.hide
					button_log.set_text ("Show Log")
				else
					-- Show log
					text_log.show
					button_log.set_text ("Hide Log")
				end
		end

	activate_player_buttons(a_index_of_current_player: INTEGER; a_enable: BOOLEAN)
		require
			a_index_of_current_player > 0 and a_index_of_current_player <= 2
		local
			counter: INTEGER
		do
			from
				counter := 1 + (a_index_of_current_player - 1) * ({GAME_CONSTANTS}.num_of_holes // 2)
			until
				counter > (1 + (a_index_of_current_player - 1)) * ({GAME_CONSTANTS}.num_of_holes // 2)
			loop
				-- Enable select and deselect all
				if a_enable then
					list_button_hole.i_th (counter).enable_sensitive
				else
					list_button_hole.i_th (counter).disable_sensitive
				end
				counter := counter + 1
			end
		end

	activate_current_player_buttons (a_current_state: GAME_STATE)
		do

			if attached {ADVERSARY_STATE} a_current_state as adv_state then
				if attached {HUMAN_PLAYER} a_current_state.current_player then
					activate_player_buttons(adv_state.index_of_current_player, true)
					activate_player_buttons((adv_state.index_of_current_player \\ 2) + 1, false)
				else
					activate_player_buttons(1, false)
					activate_player_buttons(2, false)
				end
			end

		end

		show_last_move (a_current_state: GAME_STATE)
			local
				counter: INTEGER
			do
				from
					counter := 1
				until
					counter > {GAME_CONSTANTS}.num_of_holes
				loop
					-- Enable select and deselect all
					if (attached {ADVERSARY_STATE} a_current_state as adv_state) and then adv_state.parent /= VOID then

						if counter = adv_state.rule_applied.get_selection then
							list_button_hole.i_th (counter).set_background_color (create {EV_COLOR}.make_with_8_bit_rgb (150, 150, 150))
						else
							list_button_hole.i_th (counter).set_background_color (default_button_color)
						end

					end
					counter := counter + 1
				end

			end

feature -- Inherited from VIEW
	start_view (a_game_manager: GAME_MANAGER)
		do
			game_manager := a_game_manager
			send_action_to_game_manager (create {ACTION_OTHER}.make ((create {ENUM_OTHER}).start_game))
		end

	show_state (a_current_state: GAME_STATE)
			-- Used to show a representation of the current state:
			-- the GUI updates its values (labels text, etc...), the CLI can print the state;
		do
			activate_current_player_buttons (a_current_state)
			show_last_move (a_current_state)
			update_holes (a_current_state)
			update_stores (a_current_state)
		end

	show_message (a_message: STRING)
			-- Used to communicate generic messages to the client,
			-- for instance an error message or a notification which should be displayed to the user
		do
			text_log.append_text (a_message)
			text_log.scroll_to_end
		end

feature {NONE} -- Auxiliary features

	update_holes (a_current_state: GAME_STATE)
			-- Updates holes
		local
			counter: INTEGER
		do
			from
				counter := 1
			until
				counter > 12
			loop
				list_button_hole.i_th (counter).set_text ((a_current_state.map.get_hole_value (counter).out))
				counter := counter + 1
			end
		end

	update_stores (a_current_state: GAME_STATE)
			-- Update stores
		do
			label_store_1_value.set_text ((a_current_state.map.get_store_value (1)).out)
			label_store_2_value.set_text ((a_current_state.map.get_store_value (2)).out)
		end


end
