note
	description: "EiffelVision Widget MAIN_WINDOW.The original version of this class was generated by EiffelBuild."
	generator: "EiffelBuild"
	date: "$Date: 2010-12-22 10:39:24 -0800 (Wed, 22 Dec 2010) $"
	revision: "$Revision: 85202 $"

class
	MAIN_WINDOW

inherit

	MAIN_WINDOW_IMP

feature {NONE} -- Auxiliary objects

	adversary_algorithms, solitaire_algorithms: LINKED_LIST [EV_LIST_ITEM]

	algorithms_with_depth: LIST [STRING]

	help_window: HELP_WINDOW

feature {NONE} -- Initialization

	user_create_interface_objects
			-- Create any auxilliary objects needed for MAIN_WINDOW.
			-- Initialization for these objects must be performed in `user_initialization'.
		do
				-- Create attached types defined in class here, initialize them in `user_initialization'.
				-- Create the lists that contain all the available algorithms
			create adversary_algorithms.make
			create solitaire_algorithms.make
			create help_window
		end

	user_initialization
			-- Perform any initialization on objects created by `user_create_interface_objects'
			-- and from within current class itself.
		local
			l_adversary_algorithms, l_solitaire_algorithms: LIST [STRING]
		do
				-- Initialize types defined in current class

				-- Initializing arrays of algorithms
			l_adversary_algorithms := (create {GAME_CONSTANTS}.default_create).adversary_algorithms
			l_solitaire_algorithms := (create {GAME_CONSTANTS}.default_create).solitaire_algorithms
			algorithms_with_depth := (create {GAME_CONSTANTS}.default_create).algorithms_with_depth
			from
				l_adversary_algorithms.start
			until
				l_adversary_algorithms.exhausted
			loop
				adversary_algorithms.extend (create {EV_LIST_ITEM}.make_with_text (l_adversary_algorithms.item))
				l_adversary_algorithms.forth
			end
			from
				l_solitaire_algorithms.start
			until
				l_solitaire_algorithms.exhausted
			loop
				solitaire_algorithms.extend (create {EV_LIST_ITEM}.make_with_text (l_solitaire_algorithms.item))
				l_solitaire_algorithms.forth
			end
			algorithms_with_depth.compare_objects
			adversary_algorithms.compare_objects
			algorithms_with_depth.compare_objects

				-- Initialize the default selection
			action_select_solitaire
		end

feature {NONE} -- Implementation

	action_select_solitaire
		do
				-- Change 'combo_engines' combo box with solitaire algorithms
			combo_engines.wipe_out
			combo_engines.fill (solitaire_algorithms)
		end

	action_select_adversary
		do
				-- Change 'combo_engine' combo box with adversary algorithms
			combo_engines.wipe_out
			combo_engines.fill (adversary_algorithms)
		end

	action_select_engine
		do
				-- After selecting an engine, enable or disable 'text_field_max_depth'
				-- in order to allow a user to insert a maximum depth on some
				-- specific algorithms

				-- If the selected algorithm has a parameter
			text_field_max_depth.set_text ("3")
			if (algorithms_with_depth.has (combo_engines.selected_item.text)) then
				text_field_max_depth.enable_edit
			else
					-- Otherwise
				text_field_max_depth.disable_edit
			end
		end

	action_start_click
		local
			l_selected_algorithm: STRING
			l_gui: EV_TITLED_WINDOW
			l_game_manager: GAME_MANAGER
			l_algorithm_depth: INTEGER
			l_valid_setup: BOOLEAN
		do
				-- Create game according to the value of 'radio_button_solitaire'
				-- or 'radio_button_adversary' and 'combo_engines' and
				-- 'text_field_max_depth'
				-- Then display a new 'SINGLE_WINDOW' or 'ADVERSARY_WINDOW'
				-- Eventually, destroy 'current'

			l_valid_setup := true

				-- get selected algorithm
			l_selected_algorithm := combo_engines.selected_item.text

				-- get the depth
			if text_field_max_depth.text.is_integer_32 then
				l_algorithm_depth := text_field_max_depth.text.to_integer_32
				if l_algorithm_depth < 0 then
					l_valid_setup := false
				end
			else
				l_valid_setup := false
			end

				-- start the game if the settings are ok
			if (l_valid_setup) then
					-- create gui
				if (radio_button_adversary.is_selected) then
					l_gui := create {ADVERSARY_WINDOW}
				else
					l_gui := create {SINGLE_WINDOW}
				end
				if attached {VIEW}l_gui as l_view then
					create l_game_manager.make (l_selected_algorithm, l_algorithm_depth, l_view)
					l_view.start_view (l_game_manager)
					l_gui.show
					--current.destroy
				else
					-- Error while casting
					(create {EV_ERROR_DIALOG}.make_with_text ("Error in creating the game!")).show
				end
			else
				(create {EV_INFORMATION_DIALOG}.make_with_text ("Hey! That's not a valid maximum depth!")).show
			end
		end

	action_help_click
		do
				-- Display a new 'HELP_WINDOW' with rules and credits
			if (help_window.is_destroyed) then
				create help_window
			end
			help_window.show
		end

end
